using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using ICSharpCode.NRefactory.Ast;

namespace Palmmedia.ReportGenerator.Parser.CodeAnalysis
{
    /// <summary>
    /// Represents method information extracted from a PartCover report.
    /// </summary>
    internal class MethodInfo
    {
        /// <summary>
        /// The delimiters between parameters.
        /// </summary>
        private static string[] parameterDelimiter = new string[] { ", " };

        /// <summary>
        /// Dictionary containing some type mappings.
        /// </summary>
        private static Dictionary<string, string> typeReplacements;

        /// <summary>
        /// The name of the class.
        /// </summary>
        private string classname;

        /// <summary>
        ///  The name of the method.
        /// </summary>
        private string methodname;

        /// <summary>
        /// The return type of the method.
        /// </summary>
        private string returnType;

        /// <summary>
        /// The parameters extracted from the method signature contained in the report generated by PartCover.
        /// </summary>
        private string[] parameters;

        /// <summary>
        /// Initializes static members of the <see cref="MethodInfo"/> class.
        /// </summary>
        static MethodInfo()
        {
            typeReplacements = new Dictionary<string, string>();
            typeReplacements.Add("short", "Int16");
            typeReplacements.Add("int", "Int32");
            typeReplacements.Add("long", "Int64");
            typeReplacements.Add("float", "Single");
            typeReplacements.Add("bool", "Boolean");
            typeReplacements.Add("unsigned byte", "Byte");
            typeReplacements.Add("byte", "SByte");
            typeReplacements.Add("unsigned short", "UInt16");
            typeReplacements.Add("unsigned int", "UInt32");
            typeReplacements.Add("unsigned long", "UInt64");
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MethodInfo"/> class.
        /// </summary>
        /// <param name="classname">The name of the class.</param>
        /// <param name="methodname">The name of the method.</param>
        /// <param name="signature">The signature of the method.</param>
        public MethodInfo(string classname, string methodname, string signature)
        {
            if (classname == null)
            {
                throw new ArgumentNullException("classname");
            }

            if (methodname == null)
            {
                throw new ArgumentNullException("methodname");
            }

            if (signature == null)
            {
                throw new ArgumentNullException("signature");
            }

            this.classname = classname.Substring(classname.LastIndexOf('.') + 1); // Remove namespace declaration
            this.methodname = methodname;

            var match = Regex.Match(signature, @"(?<returnType>^\S*).*\((?<parameters>.*)\)", RegexOptions.Compiled);
            this.returnType = match.Groups["returnType"].Value;
            this.parameters = match.Groups["parameters"].Value.Split(parameterDelimiter, StringSplitOptions.RemoveEmptyEntries);
        }

        /// <summary>
        /// Gets a value indicating whether this method is a constructor.
        /// </summary>
        public bool IsConstructor
        {
            get
            {
                return this.methodname == ".ctor";
            }
        }

        /// <summary>
        /// Determines whether all parameters match.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns><c>true</c> if all parameters are equal, otherwise <c>false</c>.</returns>
        public bool AreParametersMatching(List<ParameterDeclarationExpression> parameters)
        {
            if (this.parameters.Length != parameters.Count)
            {
                return false;
            }

            for (int i = 0; i < parameters.Count; i++)
            {
                if (!AreTypesEqual(this.parameters[i], parameters[i].TypeReference))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Determines whether the method name matches.
        /// </summary>
        /// <param name="methodname">The name of the method.</param>
        /// <returns><c>true</c> if method names are equal, otherwise <c>false</c>.</returns>
        public bool DoesMethodnameMatch(string methodname)
        {
            if (this.IsConstructor)
            {
                return this.classname.Equals(methodname);
            }
            else
            {
                return this.methodname.Equals(methodname);
            }
        }

        /// <summary>
        /// Determines whether the return type matches.
        /// </summary>
        /// <param name="typeReference">The return type of the method.</param>
        /// <returns><c>true</c> if return types are equal, otherwise <c>false</c>.</returns>
        public bool DoesReturnTypeMatch(TypeReference typeReference)
        {
            return AreTypesEqual(this.returnType, typeReference);
        }

        /// <summary>
        /// Determines whether the types are equal.
        /// </summary>
        /// <param name="expectedType">The expected type.</param>
        /// <param name="typeReference">The type reference.</param>
        /// <returns><c>true</c> if parameters are equal, otherwise <c>false</c>.</returns>
        private static bool AreTypesEqual(string expectedType, TypeReference typeReference)
        {
            if (typeReference.GenericTypes.Count == 1)
            {
                typeReference = typeReference.GenericTypes[0];
            }
            else if (typeReference.GenericTypes.Count >= 2)
            {
                // This can't be handled correctly
                return true;
            }

            if (typeReference.IsArrayType)
            {
                if (!expectedType.EndsWith("[]", StringComparison.Ordinal))
                {
                    return false;
                }
                else
                {
                    expectedType = expectedType.Replace("[]", string.Empty);
                }
            }

            if (expectedType.StartsWith("ref ", StringComparison.Ordinal))
            {
                expectedType = expectedType.Replace("ref ", string.Empty);
            }

            // Replace the type string of PartCover with the type names used by .NET
            string typeReplacement;
            if (typeReplacements.TryGetValue(expectedType, out typeReplacement))
            {
                expectedType = typeReplacement;
            }

            // Validate
            if (expectedType.Equals(typeReference.Type))
            {
                return true;
            }

            if (("System." + expectedType).Equals(typeReference.Type, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            if (expectedType.Substring(expectedType.LastIndexOf('.') + 1).Equals(typeReference.Type, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            return false;
        }
    }
}
