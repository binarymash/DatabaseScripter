using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Xml.Linq;

namespace Palmmedia.ReportGenerator.Parser
{
	/// <summary>
	/// Parser for XML reports generated by PartCover 2.2.
	/// </summary>
    public class PartCover22Parser : ParserBase, IParser
	{
        /// <summary>
        /// The covered assemblies. The HashSet is used for caching.
        /// </summary>
        private HashSet<string> assembliesHashSet;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartCover22Parser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        public PartCover22Parser(XContainer report)
            : base(report)
        {
            // Init the HashSet containing the covered assemblies
            this.assembliesHashSet = new HashSet<string>(report.Descendants("type").Select(type => type.Attribute("asm").Value).Distinct());

            // Init the Dictionary containing the line coverage information
            var fileIdByFilenameDictionary = report.Descendants("file").ToDictionary(f => f.Attribute("url").Value, f => f.Attribute("id").Value);

            foreach (var assembly in this.Assemblies())
            {
                foreach (var clazz in this.ClassesInAssembly(assembly))
                {
                    foreach (var file in this.FilesOfClass(assembly, clazz))
                    {
                        var seqpntsOfFile = report.Descendants("type").Where(type => type.Attribute("asm").Value.Equals(assembly) && type.Attribute("name").Value.StartsWith(clazz, StringComparison.Ordinal)).Descendants("pt").Where(seqpnt => seqpnt.Attribute("fid") != null && seqpnt.Attribute("fid").Value.Equals(fileIdByFilenameDictionary[file])).OrderBy(seqpnt => int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture));

                        if (seqpntsOfFile.Any())
                        {
                            var coverage = new int[int.Parse(seqpntsOfFile.Last().Attribute("sl").Value, CultureInfo.InvariantCulture) + 1];

                            for (int i = 0; i < coverage.Length; i++)
                            {
                                coverage[i] = -1;
                            }

                            foreach (var seqpnt in seqpntsOfFile)
                            {
                                var index = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture);
                                var value = int.Parse(seqpnt.Attribute("visit").Value, CultureInfo.InvariantCulture);
                                coverage[index] = coverage[index] == -1 ? value : coverage[index] + value;
                            }

                            this.LineCoverageByFileDictionary.Add(assembly + "_" + clazz + "_" + file, coverage);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Determine all covered files.
        /// </summary>
        /// <returns>All covered files.</returns>
        public IEnumerable<string> Files()
        {
            return this.Report.Descendants("file").Select(f => f.Attribute("url").Value);
        }

		/// <summary>
		/// Determine all covered assemblies.
		/// </summary>
		/// <returns>All covered assemblies.</returns>
		public IEnumerable<string> Assemblies()
		{
            return this.assembliesHashSet.OrderBy(value => value);
		}

		/// <summary>
		/// Determine all covered classes within an assembly.
		/// </summary>
		/// <param name="assemblyname">The name of the assembly.</param>
		/// <returns>All covered classes within an assembly.</returns>
		public IEnumerable<string> ClassesInAssembly(string assemblyname)
		{
            if (!this.assembliesHashSet.Contains(assemblyname))
            {
                return new string[] { };
            }

            return this.Report.Descendants("type").Where(type => type.Attribute("asm").Value.Equals(assemblyname) && !type.Attribute("name").Value.Contains("__")).Select(type => type.Attribute("name").Value).OrderBy(name => name);
		}

		/// <summary>
		/// Determine all files a class is defined in.
		/// </summary>
		/// <param name="assemblyname">The name of the assembly.</param>
		/// <param name="classname">The name of the class.</param>
		/// <returns>All files a class is defined in.</returns>
		public IEnumerable<string> FilesOfClass(string assemblyname, string classname)
		{
            if (!this.assembliesHashSet.Contains(assemblyname))
            {
                return new string[] { };
            }

            var fileIds = this.Report.Descendants("type").Where(type => type.Attribute("asm").Value.Equals(assemblyname) && type.Attribute("name").Value.Equals(classname)).Elements("method").Elements("code").Elements("pt").Where(pt => pt.Attribute("fid") != null).Select(pt => pt.Attribute("fid").Value).Distinct().ToArray();
            return this.Report.Descendants("file").Where(file => fileIds.Contains(file.Attribute("id").Value)).Select(file => file.Attribute("url").Value);
		}

		/// <summary>
        /// Determine how often a line of code has been covered.
		/// If line could not be covered at all -1 is returned.
		/// </summary>
		/// <param name="assemblyname">The name of the assembly.</param>
		/// <param name="classname">The name of the class.</param>
		/// <param name="fileName">The name of the file.</param>
		/// <param name="lineNumber">The number of the line (starting with 1, not zero based).</param>
		/// <returns>Number of visits.</returns>
		public int NumberOfLineVisits(string assemblyname, string classname, string fileName, int lineNumber)
		{
            if (!this.assembliesHashSet.Contains(assemblyname))
            {
                return -1;
            }

            var key = assemblyname + "_" + classname + "_" + fileName;
            if (this.LineCoverageByFileDictionary.ContainsKey(key))
            {
                var coverage = this.LineCoverageByFileDictionary[key];
                return (coverage.Length > lineNumber) ? coverage[lineNumber] : -1;
            }
            else
            {
                return -1;
            }
		}

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.GetType().Name;
        }
	}
}
